"use strict";
/**
 * ‚ö†Ô∏è  DO NOT EDIT THE GENERATED game.js FILE! ‚ö†Ô∏è
 *
 * This TypeScript file (game.ts) is the source of truth.
 * The game.js file is automatically generated by TypeScript compiler.
 *
 * To make changes:
 * 1. Edit this file (game.ts)
 * 2. Run: npm run build (or npm run dev for watch mode)
 * 3. The game.js file will be automatically updated
 */
// English translations
const enTranslation = {
    // Meta tags and SEO
    page_title: "Skull King Score Keeper - Free Digital Scorecard & Score Tracker",
    page_description: "Free Skull King score keeper and digital scorecard. Track scores, calculate points, and enjoy pirate commentary for the Skull King card game. Mobile-friendly score tracker with automatic scoring.",
    page_keywords: "Skull King, score keeper, scorecard, score tracker, Skull King scoring, card game scorer, trick taking game, pirate game, score calculator, digital scorecard",
    og_title: "Skull King Score Keeper - Free Digital Scorecard",
    og_description: "Free digital score keeper for Skull King card game. Track scores with pirate commentary and automatic calculations.",
    twitter_description: "Free digital score keeper for Skull King card game with automatic scoring and pirate commentary.",
    app_title: "Skull King",
    // Header and navigation
    header_title: "‚öì Skull King Score Keeper ‚ò†Ô∏è",
    header_tagline: "Track Yer Plunder, Ye Scurvy Dogs!",
    // Landing page
    landing_title: "Free Skull King Score Keeper & Digital Scorecard",
    landing_description: "The ultimate Skull King score tracker with automatic calculations, pirate commentary, and mobile-friendly design. Keep track of your Skull King card game scores like a true pirate captain!",
    landing_subtitle: "Perfect Skull King Scoring Solution",
    feature_mobile: "üì± <strong>Mobile Skull King Scorecard</strong> - Works on phones, tablets, and computers",
    feature_calculator: "üßÆ <strong>Automatic Score Calculator</strong> - No more manual Skull King scoring errors",
    feature_commentary: "ü¶ú <strong>Pirate Commentary</strong> - Entertaining feedback on your Skull King gameplay",
    feature_audio: "üîä <strong>Audio Score Reader</strong> - Hear your Skull King scores announced",
    feature_saving: "üíæ <strong>Game State Saving</strong> - Never lose your Skull King scoring progress",
    start_button: "Start Your Skull King Score Tracking",
    why_choose_title: "Why Choose Our Skull King Score Keeper?",
    why_choose_description: "Whether you're playing Skull King at home, at a game night, or in a tournament, our digital scorecard makes Skull King scoring effortless. Track bids, actual tricks, bonus points, and watch your Skull King scores calculate automatically. Perfect for Skull King enthusiasts who want accurate, fast scoring.",
    // Player setup
    name_crew_title: "Name Yer Crew",
    add_pirate_button: "Add Pirate",
    set_sail_button: "Set Sail!",
    back_to_port_button: "Back to Port",
    player_placeholder: "Enter pirate name...",
    // Game section
    current_bounty_title: "Current Bounty",
    read_scores_button: "üîä Read Scores",
    game_complete_title: "üè¥‚Äç‚ò†Ô∏è Game Complete! üè¥‚Äç‚ò†Ô∏è",
    round_label: "Round",
    round_display: "Round {round}",
    record_round_button: "Record Round",
    // Round inputs
    player_label: "Player",
    bid_label: "Bid",
    won_label: "Won",
    bonus_label: "Bonus",
    score_label: "Score",
    // Modal
    confirm_action_title: "Confirm Action",
    keep_names_label: "Keep player names",
    new_players_button: "New Players",
    cancel_button: "Cancel",
    aye_button: "Aye",
    nay_button: "Nay",
    same_players_prefix: "Same Players",
    // Button labels
    new_game_button: "New Game",
    edit_round_button: "Edit Round",
    // Error messages
    min_players_error: "Ye need at least 2 pirates to sail these waters!",
    max_players_error: "Too many pirates! Maximum 8 scallywags allowed.",
    duplicate_names_error: "Each pirate needs a unique name, ye scurvy dogs!",
    max_players_add_error: "Maximum 8 pirates allowed! Can't add more players.",
    invalid_number_error: "Invalid number entered for {playerName}. Please enter valid numbers only.",
    whole_numbers_error: "All values must be whole numbers for {playerName}.",
    non_negative_error: "Bid, actual tricks, and bonus must be non-negative for {playerName}.",
    bid_exceeds_tricks_error: "{playerName}'s bid ({bid}) can't exceed {maxTricks} tricks in round {round} with {playerCount} players.",
    actual_exceeds_tricks_error: "{playerName} can't win more than {maxTricks} tricks in round {round} with {playerCount} players. Actual: {actual}",
    bonus_without_correct_bid_error: "{playerName} can only earn bonus points when correctly predicting tricks! (Bid: {bid}, Actual: {actual})",
    unreasonable_bonus_error: "{playerName}'s bonus points seem unreasonable ({bonus}). Please check your entry.",
    total_tricks_mismatch_error: "Total tricks won ({totalActual}) must equal the number of tricks available ({maxTricks}) in round {round} with {playerCount} players.",
    no_rounds_to_edit_error: "No rounds to edit!",
    browser_speech_error: "Arr! Yer browser doesn't support speech. Try a newer vessel!",
    input_error_title: "Arr! Input Error",
    fix_it_button: "Aye, I'll fix it!",
    // Commentary - Perfect rounds
    perfect_round_1: "Blimey! Every scallywag nailed their bid! The sea gods smile upon ye all!",
    perfect_round_2: "Shiver me timbers! Perfect round for all hands! Not a single miscalculation!",
    perfect_round_3: "Avast! Every pirate sailed true to their word! What sorcery be this?",
    // Commentary - Single disasters
    disaster_1: "Avast! {playerName} be sinkin' faster than a ship with no hull!",
    disaster_2: "{playerName} just sailed straight into a kraken! What a disaster!",
    disaster_3: "Blimey! {playerName} be drownin' in their own overconfidence!",
    // Commentary - Multiple big scores
    big_scores_1: "Pieces of eight! Multiple pirates be strikin' gold this round!",
    big_scores_2: "Shiver me timbers! Several captains just filled their treasure chests!",
    big_scores_3: "Multiple pirates be countin' serious doubloons after that performance!",
    // Commentary - Default
    default_1: "Another round in the books! The seas be unpredictable as always!",
    default_2: "The tide turns with each round! Stay sharp, ye scurvy dogs!",
    default_3: "Mixed fortunes this round! The ocean gives and takes as she pleases!",
    default_4: "The winds of fortune blow in mysterious ways, ye landlubbers!",
    default_5: "Some pirates swim with the sharks, others sail to victory!",
    // Start commentary
    start_1: "Batten down the hatches, me hearties! The adventure begins!",
    start_2: "Hoist the colors! Time to see which scallywag rules these waters!",
    start_3: "All hands on deck! May the best pirate claim the treasure!",
    // Winner announcements - Single winner
    winner_single_1: "Huzzah! Captain {name} emerges victorious with {score} pieces of eight! The crown of Skull King belongs to ye!",
    winner_single_2: "Avast! {name} has conquered the seven seas with {score} doubloons! All hail the new Skull King!",
    winner_single_3: "Shiver me timbers! {name} stands triumphant with {score} gold coins! Ye be the true master of these waters!",
    winner_single_4: "Blimey! {name} has plundered the most treasure with {score} pieces of eight! The Skull King's throne is yours!",
    // Winner announcements - Tie
    winner_tie_1: "Avast! We have a tie! {names} both finish with {score} pieces of eight! Ye must share the Skull King's crown!",
    winner_tie_2: "Blimey! {names} have tied with {score} doubloons each! Two captains, one throne - may the best pirate win!",
    winner_tie_3: "Shiver me timbers! {names} are deadlocked at {score} gold coins! The seas couldn't choose between such worthy pirates!",
    // Score announcements
    no_game_announce: "No active game to announce, ye landlubber!",
    ahoy_mateys: "Ahoy mateys! ",
    current_bounty_after: "Now for the current bounty after round {roundCount}... ",
    leading_fleet: "Leading the fleet, we have {name} with {score} pieces of eight! ",
    bringing_rear: "And bringing up the rear, {name} with {score} doubloons. ",
    follows_with: "{name} follows with {score} gold coins. ",
    may_winds_favor: "May the winds favor the worthy! Arrr!",
    // Footer
    disclaimer_title: "Disclaimer:",
    disclaimer_text_1: "This website is an independent fan-created score keeper for the Skull King card game. It is not affiliated with, endorsed by, or connected to Grandpa Beck's Games, the official publisher of Skull King. Skull King is a trademark of Grandpa Beck's Games.",
    disclaimer_text_2: "This tool is provided for educational and entertainment purposes to help players track their game scores.",
    feedback_text: "For feedback, suggestions, or bug reports, contact: ",
    // PWA Install
    add_to_home_title: "üì± Add to Home Screen",
    android_chrome_title: "For Android Chrome:",
    android_step_1: "Tap the menu (‚ãÆ) in browser",
    android_step_2: "Select \"Add to Home screen\"",
    android_step_3: "Tap \"Add\" to confirm",
    ios_safari_title: "For iOS Safari:",
    ios_step_1: "Tap the share button (‚éò)",
    ios_step_2: "Scroll down and tap \"Add to Home Screen\"",
    ios_step_3: "Tap \"Add\" to confirm",
    close_button: "‚úï Close",
    // New game modal
    new_game_modal_title: "Start New Game",
    new_game_modal_message: "Choose how ye want to start yer new adventure:",
    // Currencies (for score announcements)
    pieces_of_eight: "pieces of eight",
    doubloons: "doubloons",
    gold_coins: "gold coins"
};
// German translations
const deTranslation = {
    // Meta tags and SEO
    page_title: "Skull King Punktez√§hler - Kostenloses Digitales Scorecard & Punktetracker",
    page_description: "Kostenloser Skull King Punktez√§hler und digitales Scorecard. Verfolge Punkte, berechne Ergebnisse und genie√üe Piraten-Kommentare f√ºr das Skull King Kartenspiel. Mobilfreundlicher Punktetracker mit automatischer Berechnung.",
    page_keywords: "Skull King, Punktez√§hler, Scorecard, Punktetracker, Skull King Punkte, Kartenspiel Z√§hler, Stichspiel, Piratenspiel, Punkterechner, digitales Scorecard",
    og_title: "Skull King Punktez√§hler - Kostenloses Digitales Scorecard",
    og_description: "Kostenloser digitaler Punktez√§hler f√ºr das Skull King Kartenspiel. Verfolge Punkte mit Piraten-Kommentaren und automatischen Berechnungen.",
    twitter_description: "Kostenloser digitaler Punktez√§hler f√ºr das Skull King Kartenspiel mit automatischer Punkteberechnung und Piraten-Kommentaren.",
    app_title: "Skull King",
    // Header and navigation
    header_title: "‚öì Skull King Punktez√§hler ‚ò†Ô∏è",
    header_tagline: "Verfolgt Eure Beute, Ihr Schurken!",
    // Landing page
    landing_title: "Kostenloser Skull King Punktez√§hler & Digitales Scorecard",
    landing_description: "Der ultimative Skull King Punktetracker mit automatischen Berechnungen, Piraten-Kommentaren und mobilfreundlichem Design. Verfolge deine Skull King Kartenspiel-Punkte wie ein echter Piratenkapit√§n!",
    landing_subtitle: "Perfekte Skull King Punktez√§hll√∂sung",
    feature_mobile: "üì± <strong>Mobile Skull King Scorecard</strong> - Funktioniert auf Handys, Tablets und Computern",
    feature_calculator: "üßÆ <strong>Automatischer Punkterechner</strong> - Keine manuellen Skull King Punktez√§hlfehler mehr",
    feature_commentary: "ü¶ú <strong>Piraten-Kommentare</strong> - Unterhaltsame R√ºckmeldungen zu deinem Skull King Gameplay",
    feature_audio: "üîä <strong>Audio-Punkteansager</strong> - H√∂re deine Skull King Punkte verk√ºndet",
    feature_saving: "üíæ <strong>Spielstand speichern</strong> - Verliere nie wieder deinen Skull King Punktefortschritt",
    start_button: "Starte Deine Skull King Punkteverfolgung",
    why_choose_title: "Warum Unseren Skull King Punktez√§hler W√§hlen?",
    why_choose_description: "Ob du Skull King zu Hause, bei einem Spieleabend oder in einem Turnier spielst, unser digitales Scorecard macht das Skull King Punktez√§hlen m√ºhelos. Verfolge Gebote, tats√§chliche Stiche, Bonuspunkte und sieh zu, wie sich deine Skull King Punkte automatisch berechnen. Perfekt f√ºr Skull King Enthusiasten, die pr√§zise, schnelle Punktevergabe wollen.",
    // Player setup
    name_crew_title: "Nennt Eure Mannschaft",
    add_pirate_button: "Pirat Hinzuf√ºgen",
    set_sail_button: "Segel Setzen!",
    back_to_port_button: "Zur√ºck zum Hafen",
    player_placeholder: "Piratenname eingeben...",
    // Game section
    current_bounty_title: "Aktuelle Beute",
    read_scores_button: "üîä Punkte Vorlesen",
    game_complete_title: "üè¥‚Äç‚ò†Ô∏è Spiel Beendet! üè¥‚Äç‚ò†Ô∏è",
    round_label: "Runde",
    round_display: "Runde {round}",
    record_round_button: "Runde Aufzeichnen",
    // Round inputs
    player_label: "Spieler",
    bid_label: "Gebot",
    won_label: "Gewonnen",
    bonus_label: "Bonus",
    score_label: "Punkte",
    // Modal
    confirm_action_title: "Aktion Best√§tigen",
    keep_names_label: "Spielernamen behalten",
    new_players_button: "Neue Spieler",
    cancel_button: "Abbrechen",
    aye_button: "Aye",
    nay_button: "Nein",
    same_players_prefix: "Gleiche Spieler",
    // Button labels
    new_game_button: "Neues Spiel",
    edit_round_button: "Runde Bearbeiten",
    // Error messages
    min_players_error: "Ihr braucht mindestens 2 Piraten, um diese Gew√§sser zu befahren!",
    max_players_error: "Zu viele Piraten! Maximum 8 Schurken erlaubt.",
    duplicate_names_error: "Jeder Pirat braucht einen einzigartigen Namen, ihr Seehunde!",
    max_players_add_error: "Maximum 8 Piraten erlaubt! Kann keine weiteren Spieler hinzuf√ºgen.",
    invalid_number_error: "Ung√ºltige Zahl f√ºr {playerName} eingegeben. Bitte nur g√ºltige Zahlen eingeben.",
    whole_numbers_error: "Alle Werte m√ºssen ganze Zahlen f√ºr {playerName} sein.",
    non_negative_error: "Gebot, tats√§chliche Stiche und Bonus m√ºssen nicht-negativ f√ºr {playerName} sein.",
    bid_exceeds_tricks_error: "{playerName}s Gebot ({bid}) kann nicht {maxTricks} Stiche in Runde {round} mit {playerCount} Spielern √ºberschreiten.",
    actual_exceeds_tricks_error: "{playerName} kann nicht mehr als {maxTricks} Stiche in Runde {round} mit {playerCount} Spielern gewinnen. Tats√§chlich: {actual}",
    bonus_without_correct_bid_error: "{playerName} kann nur Bonuspunkte verdienen, wenn Stiche korrekt vorhergesagt werden! (Gebot: {bid}, Tats√§chlich: {actual})",
    unreasonable_bonus_error: "{playerName}s Bonuspunkte scheinen unvern√ºnftig ({bonus}). Bitte √ºberpr√ºfe deine Eingabe.",
    total_tricks_mismatch_error: "Gesamte gewonnene Stiche ({totalActual}) m√ºssen der Anzahl verf√ºgbarer Stiche ({maxTricks}) in Runde {round} mit {playerCount} Spielern entsprechen.",
    no_rounds_to_edit_error: "Keine Runden zu bearbeiten!",
    browser_speech_error: "Arrr! Euer Browser unterst√ºtzt keine Sprache. Probiert ein neueres Schiff!",
    input_error_title: "Arrr! Eingabefehler",
    fix_it_button: "Aye, ich repariere es!",
    // Commentary - Perfect rounds
    perfect_round_1: "Donnerwetter! Jeder Schuft hat sein Gebot getroffen! Die Meeresg√∂tter l√§cheln euch allen zu!",
    perfect_round_2: "Alle Wetter! Perfekte Runde f√ºr alle H√§nde! Keine einzige Fehlkalkulation!",
    perfect_round_3: "Avast! Jeder Pirat segelte treu zu seinem Wort! Was f√ºr eine Zauberei ist das?",
    // Commentary - Single disasters
    disaster_1: "Avast! {playerName} sinkt schneller als ein Schiff ohne Rumpf!",
    disaster_2: "{playerName} ist geradewegs in einen Kraken gesegelt! Was f√ºr eine Katastrophe!",
    disaster_3: "Donnerwetter! {playerName} ertrinkt in der eigenen Selbst√ºbersch√§tzung!",
    // Commentary - Multiple big scores
    big_scores_1: "St√ºcke von acht! Mehrere Piraten schlagen Gold in dieser Runde!",
    big_scores_2: "Alle Wetter! Mehrere Kapit√§ne haben gerade ihre Schatztruhen gef√ºllt!",
    big_scores_3: "Mehrere Piraten z√§hlen ernsthafte Dublonen nach dieser Leistung!",
    // Commentary - Default
    default_1: "Noch eine Runde abgehakt! Die See ist unberechenbar wie immer!",
    default_2: "Die Gezeiten wenden sich mit jeder Runde! Bleibt scharf, ihr r√§udigen Hunde!",
    default_3: "Gemischtes Gl√ºck in dieser Runde! Der Ozean gibt und nimmt, wie es ihr gef√§llt!",
    default_4: "Die Winde des Gl√ºcks wehen auf mysteri√∂se Weise, ihr Landratten!",
    default_5: "Manche Piraten schwimmen mit den Haien, andere segeln zum Sieg!",
    // Start commentary
    start_1: "Macht die Luken dicht, meine Herzen! Das Abenteuer beginnt!",
    start_2: "Hisst die Farben! Zeit zu sehen, welcher Schuft diese Gew√§sser beherrscht!",
    start_3: "Alle Mann an Deck! M√∂ge der beste Pirat den Schatz beanspruchen!",
    // Winner announcements - Single winner
    winner_single_1: "Huzzah! Kapit√§n {name} geht siegreich hervor mit {score} St√ºcken von acht! Die Krone des Skull King geh√∂rt dir!",
    winner_single_2: "Avast! {name} hat die sieben Meere mit {score} Dublonen erobert! Es lebe der neue Skull King!",
    winner_single_3: "Alle Wetter! {name} steht triumphierend mit {score} Goldm√ºnzen! Du bist der wahre Meister dieser Gew√§sser!",
    winner_single_4: "Donnerwetter! {name} hat den meisten Schatz mit {score} St√ºcken von acht gepl√ºndert! Der Thron des Skull King geh√∂rt dir!",
    // Winner announcements - Tie
    winner_tie_1: "Avast! Wir haben ein Unentschieden! {names} beenden beide mit {score} St√ºcken von acht! Ihr m√ºsst die Krone des Skull King teilen!",
    winner_tie_2: "Donnerwetter! {names} haben mit jeweils {score} Dublonen unentschieden gespielt! Zwei Kapit√§ne, ein Thron - m√∂ge der beste Pirat gewinnen!",
    winner_tie_3: "Alle Wetter! {names} sind bei {score} Goldm√ºnzen im Patt! Die See konnte nicht zwischen solch w√ºrdigen Piraten w√§hlen!",
    // Score announcements
    no_game_announce: "Kein aktives Spiel zu verk√ºnden, du Landratte!",
    ahoy_mateys: "Ahoy Kameraden! ",
    current_bounty_after: "Jetzt f√ºr die aktuelle Beute nach Runde {roundCount}... ",
    leading_fleet: "Die Flotte anf√ºhrend haben wir {name} mit {score} St√ºcken von acht! ",
    bringing_rear: "Und das Schlusslicht bildend, {name} mit {score} Dublonen. ",
    follows_with: "{name} folgt mit {score} Goldm√ºnzen. ",
    may_winds_favor: "M√∂gen die Winde den W√ºrdigen beg√ºnstigen! Arrr!",
    // Footer
    disclaimer_title: "Haftungsausschluss:",
    disclaimer_text_1: "Diese Website ist ein unabh√§ngiger, von Fans erstellter Punktez√§hler f√ºr das Skull King Kartenspiel. Sie ist nicht verbunden mit, unterst√ºtzt von oder verbunden mit Grandpa Beck's Games, dem offiziellen Herausgeber von Skull King. Skull King ist eine Marke von Grandpa Beck's Games.",
    disclaimer_text_2: "Dieses Tool wird f√ºr Bildungs- und Unterhaltungszwecke bereitgestellt, um Spielern beim Verfolgen ihrer Spielergebnisse zu helfen.",
    feedback_text: "F√ºr Feedback, Vorschl√§ge oder Fehlerberichte, kontaktiere: ",
    // PWA Install
    add_to_home_title: "üì± Zum Startbildschirm hinzuf√ºgen",
    android_chrome_title: "F√ºr Android Chrome:",
    android_step_1: "Tippe auf das Men√º (‚ãÆ) im Browser",
    android_step_2: "W√§hle \"Zum Startbildschirm hinzuf√ºgen\"",
    android_step_3: "Tippe \"Hinzuf√ºgen\" zur Best√§tigung",
    ios_safari_title: "F√ºr iOS Safari:",
    ios_step_1: "Tippe auf den Teilen-Button (‚éò)",
    ios_step_2: "Scrolle nach unten und tippe \"Zum Home-Bildschirm\"",
    ios_step_3: "Tippe \"Hinzuf√ºgen\" zur Best√§tigung",
    close_button: "‚úï Schlie√üen",
    // New game modal
    new_game_modal_title: "Neues Spiel Starten",
    new_game_modal_message: "W√§hlt, wie ihr euer neues Abenteuer beginnen wollt:",
    // Currencies (for score announcements)
    pieces_of_eight: "St√ºcke von acht",
    doubloons: "Dublonen",
    gold_coins: "Goldm√ºnzen"
};
// Spanish translations
const esTranslation = {
    // Meta tags and SEO
    page_title: "Contador de Puntos Skull King - Scorecard Digital y Tracker de Puntos Gratis",
    page_description: "Contador de puntos gratuito para Skull King y scorecard digital. Rastrea puntos, calcula resultados y disfruta comentarios piratas para el juego de cartas Skull King. Tracker de puntos m√≥vil con puntuaci√≥n autom√°tica.",
    page_keywords: "Skull King, contador de puntos, scorecard, tracker de puntos, puntuaci√≥n Skull King, contador de juego de cartas, juego de bazas, juego de piratas, calculadora de puntos, scorecard digital",
    og_title: "Contador de Puntos Skull King - Scorecard Digital Gratis",
    og_description: "Contador de puntos digital gratuito para el juego de cartas Skull King. Rastrea puntos con comentarios piratas y c√°lculos autom√°ticos.",
    twitter_description: "Contador de puntos digital gratuito para el juego de cartas Skull King con puntuaci√≥n autom√°tica y comentarios piratas.",
    app_title: "Skull King",
    // Header and navigation
    header_title: "‚öì Contador de Puntos Skull King ‚ò†Ô∏è",
    header_tagline: "¬°Rastre√° Vuestro Bot√≠n, Perros Malditos!",
    // Landing page
    landing_title: "Contador de Puntos Skull King Gratis & Scorecard Digital",
    landing_description: "El tracker de puntos definitivo para Skull King con c√°lculos autom√°ticos, comentarios piratas y dise√±o m√≥vil. ¬°Rastrea los puntos de tu juego de cartas Skull King como un verdadero capit√°n pirata!",
    landing_subtitle: "Soluci√≥n Perfecta de Puntuaci√≥n Skull King",
    feature_mobile: "üì± <strong>Scorecard M√≥vil Skull King</strong> - Funciona en tel√©fonos, tabletas y computadoras",
    feature_calculator: "üßÆ <strong>Calculadora Autom√°tica de Puntos</strong> - No m√°s errores manuales de puntuaci√≥n Skull King",
    feature_commentary: "ü¶ú <strong>Comentarios Piratas</strong> - Comentarios entretenidos sobre tu gameplay de Skull King",
    feature_audio: "üîä <strong>Lector de Puntos por Audio</strong> - Escucha tus puntos de Skull King anunciados",
    feature_saving: "üíæ <strong>Guardado del Estado del Juego</strong> - Nunca pierdas tu progreso de puntuaci√≥n de Skull King",
    start_button: "Comenz√° Tu Rastreo de Puntos Skull King",
    why_choose_title: "¬øPor Qu√© Elegir Nuestro Contador de Puntos Skull King?",
    why_choose_description: "Ya sea que juegues Skull King en casa, en una noche de juegos o en un torneo, nuestro scorecard digital hace que la puntuaci√≥n de Skull King sea sin esfuerzo. Rastrea apuestas, bazas reales, puntos bonus, y ve tus puntos de Skull King calcularse autom√°ticamente. Perfecto para entusiastas de Skull King que quieren puntuaci√≥n precisa y r√°pida.",
    // Player setup
    name_crew_title: "Nombrad Vuestra Tripulaci√≥n",
    add_pirate_button: "Agregar Pirata",
    set_sail_button: "¬°Zarpar!",
    back_to_port_button: "Volver al Puerto",
    player_placeholder: "Ingrese nombre del pirata...",
    // Game section
    current_bounty_title: "Bot√≠n Actual",
    read_scores_button: "üîä Leer Puntos",
    game_complete_title: "üè¥‚Äç‚ò†Ô∏è ¬°Juego Completo! üè¥‚Äç‚ò†Ô∏è",
    round_label: "Ronda",
    round_display: "Ronda {round}",
    record_round_button: "Registrar Ronda",
    // Round inputs
    player_label: "Jugador",
    bid_label: "Apuesta",
    won_label: "Ganadas",
    bonus_label: "Bonus",
    score_label: "Puntos",
    // Modal
    confirm_action_title: "Confirmar Acci√≥n",
    keep_names_label: "Mantener nombres de jugadores",
    new_players_button: "Nuevos Jugadores",
    cancel_button: "Cancelar",
    aye_button: "S√≠",
    nay_button: "No",
    same_players_prefix: "Mismos Jugadores",
    // Button labels
    new_game_button: "Nuevo Juego",
    edit_round_button: "Editar Ronda",
    // Error messages
    min_players_error: "¬°Necesit√°is al menos 2 piratas para navegar estas aguas!",
    max_players_error: "¬°Demasiados piratas! M√°ximo 8 bribones permitidos.",
    duplicate_names_error: "¬°Cada pirata necesita un nombre √∫nico, perros del mar!",
    max_players_add_error: "¬°M√°ximo 8 piratas permitidos! No se pueden agregar m√°s jugadores.",
    invalid_number_error: "N√∫mero inv√°lido ingresado para {playerName}. Por favor ingrese solo n√∫meros v√°lidos.",
    whole_numbers_error: "Todos los valores deben ser n√∫meros enteros para {playerName}.",
    non_negative_error: "Apuesta, bazas reales y bonus deben ser no-negativos para {playerName}.",
    bid_exceeds_tricks_error: "La apuesta de {playerName} ({bid}) no puede exceder {maxTricks} bazas en la ronda {round} con {playerCount} jugadores.",
    actual_exceeds_tricks_error: "{playerName} no puede ganar m√°s de {maxTricks} bazas en la ronda {round} con {playerCount} jugadores. Real: {actual}",
    bonus_without_correct_bid_error: "¬°{playerName} solo puede ganar puntos bonus cuando predice las bazas correctamente! (Apuesta: {bid}, Real: {actual})",
    unreasonable_bonus_error: "Los puntos bonus de {playerName} parecen irrazonables ({bonus}). Por favor verifica tu entrada.",
    total_tricks_mismatch_error: "Total de bazas ganadas ({totalActual}) debe igual el n√∫mero de bazas disponibles ({maxTricks}) en la ronda {round} con {playerCount} jugadores.",
    no_rounds_to_edit_error: "¬°No hay rondas para editar!",
    browser_speech_error: "¬°Arr! Vuestro navegador no soporta voz. ¬°Probad una nave m√°s nueva!",
    input_error_title: "¬°Arr! Error de Entrada",
    fix_it_button: "¬°S√≠, lo arreglar√©!",
    // Commentary - Perfect rounds
    perfect_round_1: "¬°Rayos! ¬°Cada granuja acert√≥ su apuesta! ¬°Los dioses del mar os sonr√≠en a todos!",
    perfect_round_2: "¬°Mil rayos! ¬°Ronda perfecta para todas las manos! ¬°Ni un solo error de c√°lculo!",
    perfect_round_3: "¬°Alto ah√≠! ¬°Cada pirata naveg√≥ fiel a su palabra! ¬øQu√© brujer√≠a es esta?",
    // Commentary - Single disasters
    disaster_1: "¬°Alto ah√≠! ¬°{playerName} se hunde m√°s r√°pido que un barco sin casco!",
    disaster_2: "¬°{playerName} acaba de navegar directo hacia un kraken! ¬°Qu√© desastre!",
    disaster_3: "¬°Rayos! ¬°{playerName} se ahoga en su propia arrogancia!",
    // Commentary - Multiple big scores
    big_scores_1: "¬°Piezas de a ocho! ¬°M√∫ltiples piratas est√°n haciendo oro esta ronda!",
    big_scores_2: "¬°Mil rayos! ¬°Varios capitanes acaban de llenar sus cofres del tesoro!",
    big_scores_3: "¬°M√∫ltiples piratas est√°n contando doblones serios despu√©s de esa actuaci√≥n!",
    // Commentary - Default
    default_1: "¬°Otra ronda en los libros! ¬°Los mares son impredecibles como siempre!",
    default_2: "¬°La marea cambia con cada ronda! ¬°Manteneos alerta, perros sarnosos!",
    default_3: "¬°Fortunas mixtas esta ronda! ¬°El oc√©ano da y quita como le place!",
    default_4: "¬°Los vientos de la fortuna soplan de maneras misteriosas, terrestres!",
    default_5: "¬°Algunos piratas nadan con los tiburones, otros navegan hacia la victoria!",
    // Start commentary
    start_1: "¬°Asegurad las escotillas, corazones m√≠os! ¬°La aventura comienza!",
    start_2: "¬°Izad los colores! ¬°Hora de ver qu√© granuja gobierna estas aguas!",
    start_3: "¬°Todos a cubierta! ¬°Que el mejor pirata reclame el tesoro!",
    // Winner announcements - Single winner
    winner_single_1: "¬°Hurra! ¬°El Capit√°n {name} emerge victorioso con {score} piezas de a ocho! ¬°La corona del Skull King te pertenece!",
    winner_single_2: "¬°Alto ah√≠! ¬°{name} ha conquistado los siete mares con {score} doblones! ¬°Salve el nuevo Skull King!",
    winner_single_3: "¬°Mil rayos! ¬°{name} se alza triunfante con {score} monedas de oro! ¬°Eres el verdadero maestro de estas aguas!",
    winner_single_4: "¬°Rayos! ¬°{name} ha saqueado el mayor tesoro con {score} piezas de a ocho! ¬°El trono del Skull King es tuyo!",
    // Winner announcements - Tie
    winner_tie_1: "¬°Alto ah√≠! ¬°Tenemos un empate! ¬°{names} ambos terminan con {score} piezas de a ocho! ¬°Deb√©is compartir la corona del Skull King!",
    winner_tie_2: "¬°Rayos! ¬°{names} han empatado con {score} doblones cada uno! ¬°Dos capitanes, un trono - que gane el mejor pirata!",
    winner_tie_3: "¬°Mil rayos! ¬°{names} est√°n empatados con {score} monedas de oro! ¬°Los mares no pudieron elegir entre piratas tan dignos!",
    // Score announcements
    no_game_announce: "¬°No hay juego activo que anunciar, terrestre!",
    ahoy_mateys: "¬°Ahoy compa√±eros! ",
    current_bounty_after: "Ahora para el bot√≠n actual despu√©s de la ronda {roundCount}... ",
    leading_fleet: "Liderando la flota, tenemos a {name} con {score} piezas de a ocho! ",
    bringing_rear: "Y cerrando la marcha, {name} con {score} doblones. ",
    follows_with: "{name} sigue con {score} monedas de oro. ",
    may_winds_favor: "¬°Que los vientos favorezcan a los dignos! ¬°Arrr!",
    // Footer
    disclaimer_title: "Descargo de responsabilidad:",
    disclaimer_text_1: "Este sitio web es un contador de puntos independiente creado por fans para el juego de cartas Skull King. No est√° afiliado, respaldado o conectado con Grandpa Beck's Games, el editor oficial de Skull King. Skull King es una marca registrada de Grandpa Beck's Games.",
    disclaimer_text_2: "Esta herramienta se proporciona con fines educativos y de entretenimiento para ayudar a los jugadores a rastrear sus puntuaciones de juego.",
    feedback_text: "Para comentarios, sugerencias o reportes de errores, contacta: ",
    // PWA Install
    add_to_home_title: "üì± Agregar a Pantalla de Inicio",
    android_chrome_title: "Para Android Chrome:",
    android_step_1: "Toca el men√∫ (‚ãÆ) en el navegador",
    android_step_2: "Selecciona \"Agregar a pantalla de inicio\"",
    android_step_3: "Toca \"Agregar\" para confirmar",
    ios_safari_title: "Para iOS Safari:",
    ios_step_1: "Toca el bot√≥n compartir (‚éò)",
    ios_step_2: "Despl√°zate hacia abajo y toca \"Agregar a pantalla de inicio\"",
    ios_step_3: "Toca \"Agregar\" para confirmar",
    close_button: "‚úï Cerrar",
    // New game modal
    new_game_modal_title: "Comenzar Nuevo Juego",
    new_game_modal_message: "Elegid c√≥mo quer√©is comenzar vuestra nueva aventura:",
    // Currencies (for score announcements)
    pieces_of_eight: "piezas de a ocho",
    doubloons: "doblones",
    gold_coins: "monedas de oro"
};
// Translation system class
class GameTranslationSystem {
    constructor() {
        this.currentLanguage = 'en';
        this.translations = {
            en: enTranslation,
            de: deTranslation,
            es: esTranslation
        };
        // Try to get saved language from localStorage
        const saved = localStorage.getItem('skull-king-language');
        if (saved && this.translations[saved]) {
            this.currentLanguage = saved;
        }
        else {
            // Auto-detect browser language
            const browserLang = navigator.language.substr(0, 2);
            if (this.translations[browserLang]) {
                this.currentLanguage = browserLang;
            }
        }
    }
    getCurrentLanguage() {
        return this.currentLanguage;
    }
    setLanguage(lang) {
        if (this.translations[lang]) {
            this.currentLanguage = lang;
            localStorage.setItem('skull-king-language', lang);
            // Trigger update event
            window.dispatchEvent(new CustomEvent('languageChanged', { detail: lang }));
        }
    }
    translate(key, params) {
        const translation = this.translations[this.currentLanguage];
        if (!translation || !translation[key]) {
            console.warn(`Translation missing for key: ${key} in language: ${this.currentLanguage}`);
            return this.translations['en'][key] || key;
        }
        let result = translation[key];
        // Replace parameters if provided
        if (params) {
            Object.entries(params).forEach(([param, value]) => {
                result = result.replace(new RegExp(`\\{${param}\\}`, 'g'), value.toString());
            });
        }
        return result;
    }
}
// Global translation system instance
const translationSystem = new GameTranslationSystem();
// Create backward-compatible global i18n object
const i18n = translationSystem;
// Make it available globally for browser environment
if (typeof window !== 'undefined') {
    window.i18n = i18n;
}
else if (typeof global !== 'undefined') {
    global.i18n = i18n;
}
/**
 * GameState - Handles data persistence and storage
 * Pure data layer that only manages localStorage operations
 */
class GameState {
    constructor() {
        this.storageKey = 'skullKingGameState';
    }
    load() {
        const saved = localStorage.getItem(this.storageKey);
        return saved ? JSON.parse(saved) : null;
    }
    save(state) {
        localStorage.setItem(this.storageKey, JSON.stringify(state));
    }
    clear() {
        localStorage.removeItem(this.storageKey);
    }
    getDefaultState() {
        return {
            players: [],
            rounds: [],
            currentRound: 1
        };
    }
}
/**
 * GameViewModel - Contains all business logic and state management
 * Manages game rules, scoring calculations, validation, and analytics
 */
class GameViewModel {
    constructor() {
        this.tempPlayers = [];
        this.modalConfirmCallback = null;
        this.gameState = new GameState();
        this.state = this.gameState.load() || this.gameState.getDefaultState();
    }
    // State Management
    getGameState() {
        return Object.assign({}, this.state);
    }
    saveState() {
        this.gameState.save(this.state);
    }
    clearState() {
        this.gameState.clear();
        this.state = this.gameState.getDefaultState();
    }
    // Player Management
    getTempPlayers() {
        return [...this.tempPlayers];
    }
    initializeTempPlayers() {
        this.tempPlayers = this.state.players.map(p => p.name);
        if (this.tempPlayers.length === 0) {
            this.tempPlayers = [''];
        }
    }
    updateTempPlayer(index, value) {
        this.tempPlayers[index] = value;
    }
    addTempPlayer() {
        this.tempPlayers.push('');
    }
    removeTempPlayer(index) {
        if (this.tempPlayers.length > 1) {
            this.tempPlayers.splice(index, 1);
        }
        else {
            this.tempPlayers[0] = '';
        }
    }
    setTempPlayers(players) {
        this.tempPlayers = [...players];
    }
    validateAndStartGame() {
        const validNames = this.tempPlayers.filter(name => name.trim() !== '');
        if (validNames.length < 2) {
            return this.t('min_players_error');
        }
        if (validNames.length > 8) {
            return this.t('max_players_error');
        }
        // Check for duplicate names
        const uniqueNames = new Set(validNames.map(name => name.trim().toLowerCase()));
        if (uniqueNames.size !== validNames.length) {
            return this.t('duplicate_names_error');
        }
        // Initialize game state
        this.state.players = validNames.map(name => ({ name: name.trim(), score: 0 }));
        this.state.rounds = [];
        this.state.currentRound = 1;
        this.saveState();
        // Track analytics
        this.trackEvent('game_start', {
            event_category: 'game',
            event_label: 'new_game',
            player_count: this.state.players.length,
            value: this.state.players.length
        });
        return null; // Success
    }
    // Scoring Logic
    calculateRoundScore(bid, actual, bonus, roundNumber) {
        if (bid === 0) {
            // Zero bid scoring
            return actual === 0 ? 10 * roundNumber + bonus : -10 * roundNumber;
        }
        else {
            // Non-zero bid scoring
            if (bid === actual) {
                // Correct prediction: 20 points per trick + bonus
                return 20 * actual + bonus;
            }
            else {
                // Incorrect prediction: -10 points per difference (no bonus)
                return -10 * Math.abs(bid - actual);
            }
        }
    }
    // Input Validation
    validateSinglePlayerInput(bid, actual, bonus, playerName, roundNumber) {
        const targetRound = roundNumber || this.state.currentRound;
        // Check for invalid numbers (NaN)
        if (isNaN(bid) || isNaN(actual) || isNaN(bonus)) {
            return this.t('invalid_number_error', { playerName });
        }
        // Integer validation
        if (!Number.isInteger(bid) || !Number.isInteger(actual) || !Number.isInteger(bonus)) {
            return this.t('whole_numbers_error', { playerName });
        }
        // Basic validation
        if (bid < 0 || actual < 0 || bonus < 0) {
            return this.t('non_negative_error', { playerName });
        }
        // Round-specific validation: bids and actual tricks can't exceed available cards
        const maxTricks = this.getCardsPerRound(targetRound, this.state.players.length);
        if (bid > maxTricks) {
            return this.t('bid_exceeds_tricks_error', {
                playerName,
                bid: bid.toString(),
                maxTricks: maxTricks.toString(),
                round: targetRound.toString(),
                playerCount: this.state.players.length.toString()
            });
        }
        if (actual > maxTricks) {
            return this.t('actual_exceeds_tricks_error', {
                playerName,
                maxTricks: maxTricks.toString(),
                round: targetRound.toString(),
                playerCount: this.state.players.length.toString(),
                actual: actual.toString()
            });
        }
        // Bonus point validation - only applies when correctly predicting tricks
        if (bid !== actual && bonus > 0) {
            return this.t('bonus_without_correct_bid_error', {
                playerName,
                bid: bid.toString(),
                actual: actual.toString()
            });
        }
        // Reasonable bonus limits
        if (Math.abs(bonus) > 100) {
            return this.t('unreasonable_bonus_error', {
                playerName,
                bonus: bonus.toString()
            });
        }
        return null; // Valid
    }
    // Round Management
    getCurrentRoundNumber() {
        return this.state.currentRound;
    }
    // Card distribution logic for Skull King (70 card deck)
    getCardsPerRound(roundNumber, playerCount) {
        // Skull King is a 10-round game - rounds beyond 10 are invalid
        if (roundNumber > 10) {
            throw new Error(`Invalid round number: ${roundNumber}. Skull King only has 10 rounds.`);
        }
        // Basic validation
        if (roundNumber < 1) {
            throw new Error(`Invalid round number: ${roundNumber}. Round number must be 1 or greater.`);
        }
        if (playerCount < 1) {
            throw new Error(`Invalid player count: ${playerCount}. Must have at least 1 player.`);
        }
        const totalCards = 70;
        const idealCards = roundNumber;
        const cardsNeeded = idealCards * playerCount;
        // If we can deal the ideal number of cards, do so
        if (cardsNeeded <= totalCards) {
            return idealCards;
        }
        // Otherwise, calculate the maximum cards we can deal per player
        return Math.floor(totalCards / playerCount);
    }
    // Get maximum tricks available for current round
    getMaxTricksForCurrentRound() {
        return this.getCardsPerRound(this.state.currentRound, this.state.players.length);
    }
    validateRoundData(data, roundNumber) {
        const targetRound = roundNumber || this.state.currentRound;
        // Validate each player's input
        for (const [playerName, playerData] of Object.entries(data)) {
            const { bid, actual, bonus } = playerData;
            const validationError = this.validateSinglePlayerInput(bid, actual, bonus, playerName, targetRound);
            if (validationError) {
                return validationError;
            }
        }
        // Validate that total actual wins equals the number of tricks available
        const maxTricks = this.getCardsPerRound(targetRound, this.state.players.length);
        const totalActualWins = Object.values(data).reduce((sum, playerData) => sum + playerData.actual, 0);
        if (totalActualWins !== maxTricks) {
            return this.t('total_tricks_mismatch_error', {
                totalActual: totalActualWins.toString(),
                maxTricks: maxTricks.toString(),
                round: targetRound.toString(),
                playerCount: this.state.players.length.toString()
            });
        }
        return null; // Valid
    }
    addRound(data) {
        const validationError = this.validateRoundData(data);
        if (validationError) {
            return validationError;
        }
        const roundData = {
            roundNumber: this.state.currentRound,
            playerData: [],
            commentary: ''
        };
        // Process each player's data
        for (const player of this.state.players) {
            const playerRoundData = data[player.name];
            const roundScore = this.calculateRoundScore(playerRoundData.bid, playerRoundData.actual, playerRoundData.bonus, this.state.currentRound);
            roundData.playerData.push({
                playerName: player.name,
                bid: playerRoundData.bid,
                actual: playerRoundData.actual,
                bonus: playerRoundData.bonus,
                roundScore
            });
            // Update player's total score
            player.score += roundScore;
        }
        // Generate commentary for this round
        roundData.commentary = this.generateRoundCommentary(roundData);
        this.state.rounds.push(roundData);
        this.state.currentRound++;
        this.saveState();
        // Track analytics
        this.trackEvent('round_complete', {
            event_category: 'gameplay',
            event_label: 'round_finished',
            round_number: roundData.roundNumber,
            player_count: this.state.players.length,
            value: roundData.roundNumber
        });
        return null; // Success
    }
    removeLastRound() {
        if (this.state.rounds.length === 0) {
            return null;
        }
        const lastRound = this.state.rounds.pop();
        // Revert scores from the removed round
        for (const playerData of lastRound.playerData) {
            const player = this.state.players.find(p => p.name === playerData.playerName);
            if (player) {
                player.score -= playerData.roundScore;
            }
        }
        // Decrease current round number
        this.state.currentRound = Math.max(1, this.state.currentRound - 1);
        this.saveState();
        // Track analytics
        this.trackEvent('round_removed', {
            event_category: 'gameplay',
            event_label: 'round_deleted',
            round_number: lastRound.roundNumber,
            value: lastRound.roundNumber
        });
        // Return the round data for pre-filling inputs
        const result = {};
        for (const playerData of lastRound.playerData) {
            result[playerData.playerName] = {
                bid: playerData.bid,
                actual: playerData.actual,
                bonus: playerData.bonus
            };
        }
        return result;
    }
    // Modal Management
    setModalConfirmCallback(callback) {
        this.modalConfirmCallback = callback;
    }
    executeModalConfirm() {
        if (this.modalConfirmCallback) {
            this.modalConfirmCallback();
            this.modalConfirmCallback = null;
        }
    }
    // New Game Logic
    startNewGame(keepNames) {
        const existingNames = keepNames ? this.state.players.map(p => p.name) : [];
        this.clearState();
        if (existingNames.length > 0) {
            this.tempPlayers = [...existingNames];
        }
        else {
            this.tempPlayers = [''];
        }
        // Track analytics
        this.trackEvent('new_game_started', {
            event_category: 'navigation',
            event_label: keepNames ? 'same_players' : 'new_players',
            kept_names: keepNames,
            player_count: existingNames.length,
            value: existingNames.length
        });
    }
    // Analytics
    trackEvent(eventName, parameters = {}) {
        console.log('üîç Analytics Event:', eventName, parameters);
        if (typeof gtag !== 'undefined') {
            gtag('event', eventName, parameters);
            console.log('‚úÖ Event sent to Google Analytics');
        }
        else {
            console.warn('‚ö†Ô∏è gtag not available - analytics event not sent');
        }
    }
    // Game Status
    isGameActive() {
        return this.state.players.length > 0;
    }
    isGameComplete() {
        return this.state.currentRound > 10;
    }
    hasRounds() {
        return this.state.rounds.length > 0;
    }
    getPlayerCount() {
        return this.state.players.length;
    }
    getRoundCount() {
        return this.state.rounds.length;
    }
    // Get players sorted by score (highest first)
    getPlayersSortedByScore() {
        return [...this.state.players].sort((a, b) => b.score - a.score);
    }
    // Commentary generation for a specific round
    generateRoundCommentary(roundData) {
        const perfectPlayers = roundData.playerData.filter(p => p.bid === p.actual);
        const disasters = roundData.playerData.filter(p => Math.abs(p.bid - p.actual) >= 3);
        const bigScores = roundData.playerData.filter(p => p.roundScore >= 40);
        let commentaryMeta = {};
        // Perfect round (everyone got their bid)
        if (perfectPlayers.length === this.state.players.length) {
            const index = Math.floor(Math.random() * 3);
            commentaryMeta = { type: 'perfect', index };
            const comments = [
                this.t('perfect_round_1'),
                this.t('perfect_round_2'),
                this.t('perfect_round_3')
            ];
            roundData.commentaryMeta = commentaryMeta;
            return comments[index];
        }
        // Single disaster
        if (disasters.length === 1) {
            const player = disasters[0];
            const index = Math.floor(Math.random() * 3);
            commentaryMeta = { type: 'disaster', index, playerName: player.playerName };
            const comments = [
                this.t('disaster_1', { playerName: player.playerName }),
                this.t('disaster_2', { playerName: player.playerName }),
                this.t('disaster_3', { playerName: player.playerName })
            ];
            roundData.commentaryMeta = commentaryMeta;
            return comments[index];
        }
        // Multiple big scores
        if (bigScores.length >= 2) {
            const index = Math.floor(Math.random() * 3);
            commentaryMeta = { type: 'big_scores', index };
            const comments = [
                this.t('big_scores_1'),
                this.t('big_scores_2'),
                this.t('big_scores_3')
            ];
            roundData.commentaryMeta = commentaryMeta;
            return comments[index];
        }
        // Default commentary - always return something
        const index = Math.floor(Math.random() * 5);
        commentaryMeta = { type: 'default', index };
        const defaultComments = [
            this.t('default_1'),
            this.t('default_2'),
            this.t('default_3'),
            this.t('default_4'),
            this.t('default_5')
        ];
        roundData.commentaryMeta = commentaryMeta;
        return defaultComments[index];
    }
    // Regenerate commentary from metadata (for language changes)
    regenerateCommentaryFromMeta(meta) {
        if (!meta)
            return this.t('default_1');
        switch (meta.type) {
            case 'perfect':
                const perfectComments = [
                    this.t('perfect_round_1'),
                    this.t('perfect_round_2'),
                    this.t('perfect_round_3')
                ];
                return perfectComments[meta.index] || perfectComments[0];
            case 'disaster':
                const disasterComments = [
                    this.t('disaster_1', { playerName: meta.playerName }),
                    this.t('disaster_2', { playerName: meta.playerName }),
                    this.t('disaster_3', { playerName: meta.playerName })
                ];
                return disasterComments[meta.index] || disasterComments[0];
            case 'big_scores':
                const bigScoreComments = [
                    this.t('big_scores_1'),
                    this.t('big_scores_2'),
                    this.t('big_scores_3')
                ];
                return bigScoreComments[meta.index] || bigScoreComments[0];
            case 'start':
                const startComments = [
                    this.t('start_1'),
                    this.t('start_2'),
                    this.t('start_3')
                ];
                return startComments[meta.index] || startComments[0];
            case 'default':
            default:
                const defaultComments = [
                    this.t('default_1'),
                    this.t('default_2'),
                    this.t('default_3'),
                    this.t('default_4'),
                    this.t('default_5')
                ];
                return defaultComments[meta.index] || defaultComments[0];
        }
    }
    // Get commentary for current state (for voice reading)
    getCurrentCommentary() {
        if (this.state.rounds.length === 0) {
            const startComments = [
                this.t('start_1'),
                this.t('start_2'),
                this.t('start_3')
            ];
            return startComments[Math.floor(Math.random() * startComments.length)];
        }
        // Return the commentary from the most recent round, regenerated in current language
        const lastRound = this.state.rounds[this.state.rounds.length - 1];
        if (lastRound.commentaryMeta) {
            const regeneratedCommentary = this.regenerateCommentaryFromMeta(lastRound.commentaryMeta);
            // Update the stored commentary text to match current language
            lastRound.commentary = regeneratedCommentary;
            return regeneratedCommentary;
        }
        return lastRound.commentary; // Fallback to stored text for backwards compatibility
    }
    // Update all round commentaries to current language
    updateAllCommentariesToCurrentLanguage() {
        this.state.rounds.forEach(round => {
            if (round.commentaryMeta) {
                round.commentary = this.regenerateCommentaryFromMeta(round.commentaryMeta);
            }
        });
    }
    // Winner determination
    getWinner() {
        if (this.state.players.length === 0)
            return null;
        const sortedPlayers = [...this.state.players].sort((a, b) => b.score - a.score);
        const highestScore = sortedPlayers[0].score;
        // Return all players with the highest score (in case of tie)
        return sortedPlayers.filter(player => player.score === highestScore);
    }
    generateWinnerAnnouncement() {
        const winners = this.getWinner();
        if (!winners || winners.length === 0) {
            return "The seas have claimed all! No winners this voyage!";
        }
        if (winners.length === 1) {
            const winner = winners[0];
            const winnerMessages = [
                this.t('winner_single_1', { name: winner.name, score: winner.score.toString() }),
                this.t('winner_single_2', { name: winner.name, score: winner.score.toString() }),
                this.t('winner_single_3', { name: winner.name, score: winner.score.toString() }),
                this.t('winner_single_4', { name: winner.name, score: winner.score.toString() })
            ];
            return winnerMessages[Math.floor(Math.random() * winnerMessages.length)];
        }
        else {
            // Multiple winners (tie)
            const winnerNames = winners.map(w => w.name).join(' and ');
            const score = winners[0].score;
            const tieMessages = [
                this.t('winner_tie_1', { names: winnerNames, score: score.toString() }),
                this.t('winner_tie_2', { names: winnerNames, score: score.toString() }),
                this.t('winner_tie_3', { names: winnerNames, score: score.toString() })
            ];
            return tieMessages[Math.floor(Math.random() * tieMessages.length)];
        }
    }
    // Text-to-Speech
    createScoreAnnouncement() {
        if (this.state.players.length === 0) {
            return this.t('no_game_announce');
        }
        let announcement = this.t('ahoy_mateys');
        // Always use the current commentary from the viewmodel
        const commentary = this.getCurrentCommentary();
        announcement += `${commentary} `;
        const sortedPlayers = [...this.state.players].sort((a, b) => b.score - a.score);
        announcement += this.t('current_bounty_after', { roundCount: this.state.rounds.length.toString() });
        sortedPlayers.forEach((player, index) => {
            if (index === 0) {
                announcement += this.t('leading_fleet', { name: player.name, score: player.score.toString() });
            }
            else if (index === sortedPlayers.length - 1 && sortedPlayers.length > 2) {
                announcement += this.t('bringing_rear', { name: player.name, score: player.score.toString() });
            }
            else {
                announcement += this.t('follows_with', { name: player.name, score: player.score.toString() });
            }
        });
        announcement += this.t('may_winds_favor');
        return announcement;
    }
    // Safe translation helper
    t(key, params) {
        return translationSystem.translate(key, params);
    }
    // Public method for testing
    testCalculateRoundScore(bid, actual, bonus, roundNumber) {
        return this.calculateRoundScore(bid, actual, bonus, roundNumber);
    }
}
/**
 * SkullKingGame - Main game controller using MVVM architecture
 * Coordinates between ViewModel (business logic) and DOM (view)
 */
class SkullKingGame {
    constructor() {
        this.deferredPrompt = null;
        this.viewModel = new GameViewModel();
        this.init();
    }
    init() {
        this.setupEventListeners();
        this.initializePWA();
        this.initializeTranslations();
        this.updateUI();
    }
    setupEventListeners() {
        // Landing page
        const newGameBtn = document.getElementById('new-game-btn');
        newGameBtn === null || newGameBtn === void 0 ? void 0 : newGameBtn.addEventListener('click', () => this.handleNewGame());
        // Player names setup
        const addPlayerBtn = document.getElementById('add-player-btn');
        addPlayerBtn === null || addPlayerBtn === void 0 ? void 0 : addPlayerBtn.addEventListener('click', () => this.handleAddPlayer());
        const startGameBtn = document.getElementById('start-game-btn');
        startGameBtn === null || startGameBtn === void 0 ? void 0 : startGameBtn.addEventListener('click', () => this.handleStartGame());
        const cancelSetupBtn = document.getElementById('cancel-setup-btn');
        cancelSetupBtn === null || cancelSetupBtn === void 0 ? void 0 : cancelSetupBtn.addEventListener('click', () => this.showLanding());
        // In-game
        const newGameIngameBtn = document.getElementById('new-game-ingame-btn');
        newGameIngameBtn === null || newGameIngameBtn === void 0 ? void 0 : newGameIngameBtn.addEventListener('click', () => this.confirmNewGame());
        const addRoundBtn = document.getElementById('add-round-btn');
        addRoundBtn === null || addRoundBtn === void 0 ? void 0 : addRoundBtn.addEventListener('click', () => this.handleAddRound());
        const readScoresBtn = document.getElementById('read-scores-btn');
        readScoresBtn === null || readScoresBtn === void 0 ? void 0 : readScoresBtn.addEventListener('click', () => this.readScores());
        // Modal
        const modalConfirm = document.getElementById('modal-confirm');
        modalConfirm === null || modalConfirm === void 0 ? void 0 : modalConfirm.addEventListener('click', () => this.handleModalConfirm());
        const modalCancel = document.getElementById('modal-cancel');
        modalCancel === null || modalCancel === void 0 ? void 0 : modalCancel.addEventListener('click', () => this.hideModal());
        // New Game Modal Options
        const samePlayersBtn = document.getElementById('same-players-btn');
        samePlayersBtn === null || samePlayersBtn === void 0 ? void 0 : samePlayersBtn.addEventListener('click', () => this.handleSamePlayersNewGame());
        const newPlayersBtn = document.getElementById('new-players-btn');
        newPlayersBtn === null || newPlayersBtn === void 0 ? void 0 : newPlayersBtn.addEventListener('click', () => this.handleNewPlayersNewGame());
        const cancelNewGameBtn = document.getElementById('cancel-new-game-btn');
        cancelNewGameBtn === null || cancelNewGameBtn === void 0 ? void 0 : cancelNewGameBtn.addEventListener('click', () => this.hideModal());
        // Language selector
        const languageSelector = document.getElementById('language-selector');
        languageSelector === null || languageSelector === void 0 ? void 0 : languageSelector.addEventListener('change', () => this.handleLanguageChange(languageSelector.value));
    }
    // Event Handlers
    handleNewGame() {
        if (this.viewModel.isGameActive()) {
            this.confirmNewGame();
        }
        else {
            this.startPlayerSetup();
        }
    }
    handleAddPlayer() {
        const tempPlayers = this.viewModel.getTempPlayers();
        if (tempPlayers.length >= 8) {
            this.showError(this.t('max_players_add_error'));
            return;
        }
        this.viewModel.addTempPlayer();
        this.updatePlayerInputs();
    }
    handleStartGame() {
        const error = this.viewModel.validateAndStartGame();
        if (error) {
            this.showError(error);
            return;
        }
        this.updateUI();
    }
    handleAddRound() {
        const gameState = this.viewModel.getGameState();
        const roundData = this.collectRoundData(gameState.players);
        const error = this.viewModel.addRound(roundData);
        if (error) {
            this.showError(error);
            return;
        }
        this.updateUI();
        this.clearRoundInputs();
        this.showCommentary();
        // Scroll to the scores section after recording round
        const scoresSection = document.querySelector('.current-scores');
        if (scoresSection) {
            scoresSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    }
    handleModalConfirm() {
        this.viewModel.executeModalConfirm();
        this.hideModal();
    }
    handleSamePlayersNewGame() {
        this.viewModel.startNewGame(true); // Keep names
        this.hideModal();
        // If we have valid players from keeping names, start the game immediately
        const tempPlayers = this.viewModel.getTempPlayers();
        const validNames = tempPlayers.filter(name => name.trim() !== '');
        if (validNames.length >= 2) {
            const error = this.viewModel.validateAndStartGame();
            if (!error) {
                this.updateUI();
                return;
            }
        }
        // Otherwise, go to player setup
        this.startPlayerSetup();
    }
    handleNewPlayersNewGame() {
        this.viewModel.startNewGame(false); // Don't keep names
        this.hideModal();
        this.startPlayerSetup();
    }
    // Helper Methods
    startPlayerSetup() {
        this.viewModel.initializeTempPlayers();
        this.showPlayerSetup();
        this.updatePlayerInputs();
    }
    confirmNewGame() {
        const gameState = this.viewModel.getGameState();
        const playerNames = gameState.players.map(p => p.name).join(', ');
        this.showNewGameModal(this.t('new_game_modal_title'), this.t('new_game_modal_message'), playerNames);
    }
    // View Methods
    updateUI() {
        const gameState = this.viewModel.getGameState();
        if (gameState.players.length === 0) {
            this.showLanding();
        }
        else {
            this.showGame();
            this.updateScoreDisplay(gameState.players);
            // Check if game is complete
            const isGameComplete = this.viewModel.isGameComplete();
            if (isGameComplete) {
                this.showWinnerAnnouncement();
                this.hideNewRoundInputs();
            }
            else {
                this.hideWinnerAnnouncement();
                this.showNewRoundInputs();
                this.updateRoundInputs(gameState.players, gameState.currentRound);
            }
            this.updatePreviousRounds(gameState.rounds);
            // Show commentary if we have rounds
            if (gameState.rounds.length > 0) {
                this.showCommentary();
            }
        }
    }
    showLanding() {
        var _a, _b, _c, _d;
        (_a = document.getElementById('landing-section')) === null || _a === void 0 ? void 0 : _a.classList.remove('hidden');
        (_b = document.getElementById('player-names-section')) === null || _b === void 0 ? void 0 : _b.classList.add('hidden');
        (_c = document.getElementById('game-section')) === null || _c === void 0 ? void 0 : _c.classList.add('hidden');
        (_d = document.getElementById('new-game-section')) === null || _d === void 0 ? void 0 : _d.classList.add('hidden');
    }
    showPlayerSetup() {
        var _a, _b, _c, _d;
        (_a = document.getElementById('landing-section')) === null || _a === void 0 ? void 0 : _a.classList.add('hidden');
        (_b = document.getElementById('player-names-section')) === null || _b === void 0 ? void 0 : _b.classList.remove('hidden');
        (_c = document.getElementById('game-section')) === null || _c === void 0 ? void 0 : _c.classList.add('hidden');
        (_d = document.getElementById('new-game-section')) === null || _d === void 0 ? void 0 : _d.classList.add('hidden');
    }
    showGame() {
        var _a, _b, _c, _d;
        (_a = document.getElementById('landing-section')) === null || _a === void 0 ? void 0 : _a.classList.add('hidden');
        (_b = document.getElementById('player-names-section')) === null || _b === void 0 ? void 0 : _b.classList.add('hidden');
        (_c = document.getElementById('game-section')) === null || _c === void 0 ? void 0 : _c.classList.remove('hidden');
        (_d = document.getElementById('new-game-section')) === null || _d === void 0 ? void 0 : _d.classList.remove('hidden');
    }
    updatePlayerInputs() {
        const container = document.getElementById('player-names-inputs');
        const addPlayerBtn = document.getElementById('add-player-btn');
        if (!container)
            return;
        const tempPlayers = this.viewModel.getTempPlayers();
        container.innerHTML = tempPlayers.map((name, index) => `
            <div class="player-name-input">
                <input type="text" id="player-${index}" placeholder="${this.t('player_placeholder')}" value="${name}" onchange="game.updateTempPlayer(${index}, this.value)">
                <button class="btn-remove" onclick="game.removePlayer(${index})" title="Remove player">‚úï</button>
            </div>
        `).join('');
        // Hide/show Add Pirate button based on player count (max 8)
        if (addPlayerBtn) {
            if (tempPlayers.length >= 8) {
                addPlayerBtn.style.display = 'none';
            }
            else {
                addPlayerBtn.style.display = 'inline-block';
            }
        }
    }
    updateScoreDisplay(players) {
        const scoreDisplay = document.getElementById('score-display');
        if (!scoreDisplay)
            return;
        // Get players sorted by score from the view model
        const sortedPlayers = this.viewModel.getPlayersSortedByScore();
        scoreDisplay.innerHTML = sortedPlayers.map(player => `
            <div class="player-score">
                <h4>${player.name}</h4>
                <div class="score-value">${player.score}</div>
            </div>
        `).join('');
    }
    updateRoundInputs(players, currentRound) {
        const container = document.getElementById('round-inputs');
        const roundNumberEl = document.getElementById('round-number');
        if (!container)
            return;
        const maxTricks = this.viewModel.getMaxTricksForCurrentRound();
        const roundDisplay = maxTricks < currentRound ?
            `${currentRound} (${maxTricks} cards each)` :
            currentRound.toString();
        if (roundNumberEl) {
            roundNumberEl.textContent = roundDisplay;
        }
        container.innerHTML = players.map(player => `
            <div class="player-round-input">
                <h4>${player.name}</h4>
                <div class="round-input-row">
                    <div class="input-group">
                        <label for="bid-${player.name}" class="input-label">${this.t('bid_label')}</label>
                        <input type="number" id="bid-${player.name}" placeholder="0" min="0" max="${maxTricks}" oninput="game.updateRoundScore(&quot;${player.name}&quot;)">
                    </div>
                    <div class="input-group">
                        <label for="actual-${player.name}" class="input-label">${this.t('won_label')}</label>
                        <input type="number" id="actual-${player.name}" placeholder="0" min="0" max="${maxTricks}" oninput="game.updateRoundScore(&quot;${player.name}&quot;)">
                    </div>
                    <div class="input-group">
                        <label for="bonus-${player.name}" class="input-label">${this.t('bonus_label')}</label>
                        <input type="number" id="bonus-${player.name}" placeholder="0" min="0" oninput="game.updateRoundScore(&quot;${player.name}&quot;)">
                    </div>
                    <div class="input-group">
                        <label class="input-label">${this.t('score_label')}</label>
                        <div id="score-${player.name}" class="computed-score">-</div>
                    </div>
                </div>
            </div>
        `).join('');
        // Initialize computed scores for all players
        players.forEach(player => this.updateRoundScoreInternal(player.name));
    }
    updatePreviousRounds(rounds) {
        const container = document.getElementById('previous-rounds');
        if (!container)
            return;
        if (rounds.length === 0) {
            container.innerHTML = '';
            return;
        }
        // Display rounds in reverse order (newest first)
        const sortedRounds = [...rounds].reverse();
        container.innerHTML = sortedRounds.map((round, index) => `
            <div class="round-display parchment">
                <div class="round-header">
                    <h3>${this.t('round_display', { round: round.roundNumber.toString() })}</h3>
                    ${index === 0 ? `<button class="btn btn-secondary" onclick="game.handleUpdateLastRound()">${this.t('edit_round_button')}</button>` : ''}
                </div>
                <div class="round-data">
                    <div class="round-data-header">
                        <span>${this.t('player_label')}</span>
                        <span>${this.t('bid_label')}</span>
                        <span>${this.t('won_label')}</span>
                        <span>${this.t('bonus_label')}</span>
                        <span>${this.t('score_label')}</span>
                    </div>
                    ${round.playerData.map(data => `
                        <div class="player-round-data">
                            <strong>${data.playerName}</strong>
                            <span>${data.bid}</span>
                            <span>${data.actual}</span>
                            <span>${data.bonus}</span>
                            <span>${data.roundScore > 0 ? '+' : ''}${data.roundScore}</span>
                        </div>
                    `).join('')}
                </div>
            </div>
        `).join('');
    }
    collectRoundData(players) {
        var _a, _b, _c;
        const data = {};
        for (const player of players) {
            const bidInput = document.getElementById(`bid-${player.name}`);
            const actualInput = document.getElementById(`actual-${player.name}`);
            const bonusInput = document.getElementById(`bonus-${player.name}`);
            // Parse values, defaulting to 0 for empty inputs
            const bidValue = ((_a = bidInput === null || bidInput === void 0 ? void 0 : bidInput.value) === null || _a === void 0 ? void 0 : _a.trim()) || '0';
            const actualValue = ((_b = actualInput === null || actualInput === void 0 ? void 0 : actualInput.value) === null || _b === void 0 ? void 0 : _b.trim()) || '0';
            const bonusValue = ((_c = bonusInput === null || bonusInput === void 0 ? void 0 : bonusInput.value) === null || _c === void 0 ? void 0 : _c.trim()) || '0';
            data[player.name] = {
                bid: parseInt(bidValue),
                actual: parseInt(actualValue),
                bonus: parseInt(bonusValue)
            };
        }
        return data;
    }
    clearRoundInputs() {
        const inputs = document.querySelectorAll('#round-inputs input');
        inputs.forEach(input => input.value = '');
    }
    showCommentary() {
        const commentary = this.viewModel.getCurrentCommentary();
        const commentaryEl = document.getElementById('pirate-commentary');
        const textEl = document.getElementById('commentary-text');
        if (commentaryEl && textEl) {
            if (commentary) {
                textEl.textContent = commentary;
                commentaryEl.classList.remove('hidden');
            }
            else {
                commentaryEl.classList.add('hidden');
            }
        }
    }
    showWinnerAnnouncement() {
        const winnerAnnouncement = document.getElementById('winner-announcement');
        const winnerText = document.getElementById('winner-text');
        if (winnerAnnouncement && winnerText) {
            const announcement = this.viewModel.generateWinnerAnnouncement();
            winnerText.textContent = announcement;
            winnerAnnouncement.classList.remove('hidden');
        }
    }
    hideWinnerAnnouncement() {
        const winnerAnnouncement = document.getElementById('winner-announcement');
        if (winnerAnnouncement) {
            winnerAnnouncement.classList.add('hidden');
        }
    }
    showNewRoundInputs() {
        const newRoundEl = document.getElementById('new-round');
        if (newRoundEl) {
            newRoundEl.classList.remove('hidden');
        }
    }
    hideNewRoundInputs() {
        const newRoundEl = document.getElementById('new-round');
        if (newRoundEl) {
            newRoundEl.classList.add('hidden');
        }
    }
    showNewGameModal(title, message, playerNames) {
        const modal = document.getElementById('modal');
        const titleEl = document.getElementById('modal-title');
        const messageEl = document.getElementById('modal-message');
        const checkboxContainer = document.getElementById('modal-checkbox-container');
        const modalButtons = document.getElementById('modal-buttons');
        const modalOptions = document.getElementById('modal-options');
        const newGameOptions = document.getElementById('new-game-options');
        const samePlayersBtn = document.getElementById('same-players-btn');
        if (!modal || !titleEl || !messageEl)
            return;
        titleEl.textContent = title;
        messageEl.textContent = message;
        // Hide standard options
        checkboxContainer === null || checkboxContainer === void 0 ? void 0 : checkboxContainer.classList.add('hidden');
        modalOptions === null || modalOptions === void 0 ? void 0 : modalOptions.classList.add('hidden');
        modalButtons === null || modalButtons === void 0 ? void 0 : modalButtons.classList.add('hidden');
        // Show new game options
        newGameOptions === null || newGameOptions === void 0 ? void 0 : newGameOptions.classList.remove('hidden');
        // Update same players button text
        if (samePlayersBtn) {
            samePlayersBtn.textContent = `${this.t('same_players_prefix')} (${playerNames})`;
        }
        modal.classList.remove('hidden');
    }
    showModal(title, message, showCheckbox = false) {
        const modal = document.getElementById('modal');
        const titleEl = document.getElementById('modal-title');
        const messageEl = document.getElementById('modal-message');
        const checkboxContainer = document.getElementById('modal-checkbox-container');
        const modalButtons = document.getElementById('modal-buttons');
        const modalOptions = document.getElementById('modal-options');
        const newGameOptions = document.getElementById('new-game-options');
        if (!modal || !titleEl || !messageEl)
            return;
        titleEl.textContent = title;
        messageEl.textContent = message;
        // Hide all optional sections by default
        checkboxContainer === null || checkboxContainer === void 0 ? void 0 : checkboxContainer.classList.add('hidden');
        modalOptions === null || modalOptions === void 0 ? void 0 : modalOptions.classList.add('hidden');
        newGameOptions === null || newGameOptions === void 0 ? void 0 : newGameOptions.classList.add('hidden');
        // Show standard buttons
        modalButtons === null || modalButtons === void 0 ? void 0 : modalButtons.classList.remove('hidden');
        if (showCheckbox && checkboxContainer) {
            checkboxContainer.classList.remove('hidden');
        }
        modal.classList.remove('hidden');
    }
    showErrorModal(message) {
        const modal = document.getElementById('modal');
        const titleEl = document.getElementById('modal-title');
        const messageEl = document.getElementById('modal-message');
        const checkboxContainer = document.getElementById('modal-checkbox-container');
        const modalButtons = document.getElementById('modal-buttons');
        const modalOptions = document.getElementById('modal-options');
        const newGameOptions = document.getElementById('new-game-options');
        const modalConfirm = document.getElementById('modal-confirm');
        const modalCancel = document.getElementById('modal-cancel');
        if (!modal || !titleEl || !messageEl)
            return;
        titleEl.textContent = this.t('input_error_title');
        messageEl.textContent = message;
        // Hide all optional sections
        checkboxContainer === null || checkboxContainer === void 0 ? void 0 : checkboxContainer.classList.add('hidden');
        modalOptions === null || modalOptions === void 0 ? void 0 : modalOptions.classList.add('hidden');
        newGameOptions === null || newGameOptions === void 0 ? void 0 : newGameOptions.classList.add('hidden');
        modalButtons === null || modalButtons === void 0 ? void 0 : modalButtons.classList.remove('hidden');
        // Show only the confirm button (OK)
        if (modalConfirm && modalCancel) {
            modalConfirm.textContent = this.t('fix_it_button');
            modalCancel.style.display = 'none';
        }
        // Clear any existing callback and set error modal behavior
        this.viewModel.setModalConfirmCallback(() => {
            if (modalCancel)
                modalCancel.style.display = 'inline-block';
            if (modalConfirm)
                modalConfirm.textContent = this.t('aye_button');
        });
        modal.classList.remove('hidden');
    }
    hideModal() {
        const modal = document.getElementById('modal');
        modal === null || modal === void 0 ? void 0 : modal.classList.add('hidden');
    }
    getKeepNamesCheckbox() {
        const checkbox = document.getElementById('keep-names-checkbox');
        return (checkbox === null || checkbox === void 0 ? void 0 : checkbox.checked) || false;
    }
    showError(message) {
        this.showErrorModal(message);
    }
    getLanguageSpecificSpeechSettings(language) {
        const settings = {
            'en': {
                rate: 0.7, // Slower and more dramatic for English
                pitch: 0.7, // Lower pitch for gruff pirate voice
                volume: 1.0
            },
            'de': {
                rate: 0.65, // Slightly slower for German to sound more commanding
                pitch: 0.6, // Even lower pitch for authoritative German pirate
                volume: 1.0
            },
            'es': {
                rate: 0.75, // Slightly faster for Spanish passion
                pitch: 0.75, // Slightly higher pitch for Spanish expressiveness
                volume: 1.0
            }
        };
        return settings[language] || settings['en'];
    }
    readScores() {
        // Check if browser supports speech synthesis
        if (!('speechSynthesis' in window) || !('SpeechSynthesisUtterance' in window)) {
            this.showErrorModal(this.t('browser_speech_error'));
            return;
        }
        // Cancel any ongoing speech
        window.speechSynthesis.cancel();
        // Force refresh the view model's translation context before creating announcement
        const announcement = this.viewModel.createScoreAnnouncement();
        // Create and configure the utterance for maximum pirate effect
        const utterance = new SpeechSynthesisUtterance(announcement);
        // Get current language
        const currentLang = translationSystem.getCurrentLanguage();
        // Set the utterance language based on current selection
        utterance.lang = currentLang === 'de' ? 'de-DE' :
            currentLang === 'es' ? 'es-ES' : 'en-US';
        // Set language-specific speech parameters for pirate effect
        const speechSettings = this.getLanguageSpecificSpeechSettings(currentLang);
        utterance.rate = speechSettings.rate;
        utterance.pitch = speechSettings.pitch;
        utterance.volume = speechSettings.volume;
        // Function to set language-appropriate voice
        const setLanguageVoice = () => {
            const voices = window.speechSynthesis.getVoices();
            if (voices.length === 0) {
                // Voices not loaded yet, try again in a moment
                setTimeout(setLanguageVoice, 100);
                return;
            }
            let pirateVoice = null;
            const voicePreferences = {
                'en': {
                    langCodes: ['en-US', 'en-GB', 'en-AU', 'en'],
                    preferredNames: ['daniel', 'david', 'alex', 'male', 'aaron', 'fred']
                },
                'de': {
                    langCodes: ['de-DE', 'de-AT', 'de-CH', 'de'],
                    preferredNames: ['male', 'markus', 'stefan', 'hans', 'dieter']
                },
                'es': {
                    langCodes: ['es-ES', 'es-MX', 'es-AR', 'es-US', 'es'],
                    preferredNames: ['male', 'carlos', 'diego', 'jorge', 'manuel', 'pablo']
                }
            };
            const prefs = voicePreferences[currentLang] || voicePreferences['en'];
            // Try to find the best voice for the current language
            for (const langCode of prefs.langCodes) {
                // First, try to find preferred male voices
                for (const preferredName of prefs.preferredNames) {
                    pirateVoice = voices.find(voice => voice.lang.toLowerCase().startsWith(langCode.toLowerCase()) &&
                        voice.name.toLowerCase().includes(preferredName.toLowerCase()));
                    if (pirateVoice)
                        break;
                }
                if (pirateVoice)
                    break;
                // If no preferred voice found, try any male voice for this language
                pirateVoice = voices.find(voice => voice.lang.toLowerCase().startsWith(langCode.toLowerCase()) &&
                    !voice.name.toLowerCase().includes('female'));
                if (pirateVoice)
                    break;
                // If still no voice, try any voice for this language
                pirateVoice = voices.find(voice => voice.lang.toLowerCase().startsWith(langCode.toLowerCase()));
                if (pirateVoice)
                    break;
            }
            // Fallback to any English voice if no voice found for selected language
            if (!pirateVoice) {
                pirateVoice = voices.find(voice => voice.lang.startsWith('en') &&
                    !voice.name.toLowerCase().includes('female')) || voices.find(voice => voice.lang.startsWith('en'));
            }
            if (pirateVoice) {
                utterance.voice = pirateVoice;
                utterance.lang = pirateVoice.lang; // Set the language explicitly
                console.log(`üó£Ô∏è Using voice: ${pirateVoice.name} (${pirateVoice.lang}) for language: ${currentLang}`);
            }
            else {
                console.warn(`‚ö†Ô∏è No suitable voice found for language: ${currentLang}`);
            }
            // Speak!
            window.speechSynthesis.speak(utterance);
        };
        // Set voice and speak
        setLanguageVoice();
    }
    updateRoundScoreInternal(playerName) {
        const bidInput = document.getElementById(`bid-${playerName}`);
        const actualInput = document.getElementById(`actual-${playerName}`);
        const bonusInput = document.getElementById(`bonus-${playerName}`);
        const scoreDisplay = document.getElementById(`score-${playerName}`);
        if (!bidInput || !actualInput || !bonusInput || !scoreDisplay)
            return;
        // Get input values
        const bidValue = bidInput.value.trim();
        const actualValue = actualInput.value.trim();
        const bonusValue = bonusInput.value.trim();
        // Only show score when both bid and actual have values (Option 1: Progressive Disclosure)
        if (!bidValue || !actualValue) {
            scoreDisplay.textContent = '-';
            scoreDisplay.className = 'computed-score';
            return;
        }
        // Parse values (bonus defaults to 0 if empty)
        const bid = parseInt(bidValue);
        const actual = parseInt(actualValue);
        const bonus = bonusValue ? parseInt(bonusValue) : 0;
        // Use the centralized validation
        const validationError = this.viewModel.validateSinglePlayerInput(bid, actual, bonus, playerName);
        if (validationError) {
            scoreDisplay.textContent = '-';
            scoreDisplay.className = 'computed-score invalid';
            return;
        }
        // Calculate score
        const currentRound = this.viewModel.getCurrentRoundNumber();
        const score = this.viewModel.testCalculateRoundScore(bid, actual, bonus, currentRound);
        // Display score with appropriate styling
        scoreDisplay.textContent = score > 0 ? `+${score}` : score.toString();
        scoreDisplay.className = `computed-score ${score > 0 ? 'positive' : score < 0 ? 'negative' : 'zero'}`;
    }
    // Public API for HTML event handlers
    updateTempPlayer(index, value) {
        this.viewModel.updateTempPlayer(index, value);
    }
    removePlayer(index) {
        this.viewModel.removeTempPlayer(index);
        this.updatePlayerInputs();
    }
    updateRoundScore(playerName) {
        this.updateRoundScoreInternal(playerName);
    }
    handleUpdateLastRound() {
        // Remove the last round and get its data for pre-filling
        const lastRoundData = this.viewModel.removeLastRound();
        if (!lastRoundData) {
            this.showError(this.t('no_rounds_to_edit_error'));
            return;
        }
        // Ensure the round inputs are visible for editing, even if game was complete
        this.showNewRoundInputs();
        // Update UI to reflect the new game state (with last round removed)
        this.updateUI();
        // Populate the inputs with the removed round's data for editing
        for (const [playerName, data] of Object.entries(lastRoundData)) {
            const bidInput = document.getElementById(`bid-${playerName}`);
            const actualInput = document.getElementById(`actual-${playerName}`);
            const bonusInput = document.getElementById(`bonus-${playerName}`);
            if (bidInput)
                bidInput.value = data.bid.toString();
            if (actualInput)
                actualInput.value = data.actual.toString();
            if (bonusInput)
                bonusInput.value = data.bonus.toString();
            // Update the computed score for this player
            this.updateRoundScoreInternal(playerName);
        }
        // Scroll to the round inputs section for editing
        const roundInputsSection = document.getElementById('new-round');
        if (roundInputsSection) {
            roundInputsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    }
    // Translation Management
    initializeTranslations() {
        // Set initial language in selector
        const languageSelector = document.getElementById('language-selector');
        if (languageSelector) {
            languageSelector.value = translationSystem.getCurrentLanguage();
        }
        // Listen for language change events
        window.addEventListener('languageChanged', () => {
            this.updateAllTranslations();
        });
        // Initial translation update
        this.updateAllTranslations();
    }
    handleLanguageChange(language) {
        translationSystem.setLanguage(language);
    }
    // Safe translation helper
    t(key, params) {
        return translationSystem.translate(key, params);
    }
    updateAllTranslations() {
        // Update meta tags
        this.updateMetaTags();
        // Update static content
        this.updateStaticContent();
        // Update dynamic content if game is active
        if (this.viewModel.isGameActive()) {
            // Update all round commentaries to current language
            this.viewModel.updateAllCommentariesToCurrentLanguage();
            this.updateUI();
            // Force refresh commentary with new language
            this.showCommentary();
        }
    }
    updateMetaTags() {
        // Update document title
        const title = document.getElementById('page-title');
        if (title)
            title.textContent = this.t('page_title');
        // Update meta description
        const description = document.querySelector('meta[name="description"]');
        if (description)
            description.content = this.t('page_description');
        // Update meta keywords
        const keywords = document.querySelector('meta[name="keywords"]');
        if (keywords)
            keywords.content = this.t('page_keywords');
        // Update Open Graph tags
        const ogTitle = document.querySelector('meta[property="og:title"]');
        if (ogTitle)
            ogTitle.content = this.t('og_title');
        const ogDescription = document.querySelector('meta[property="og:description"]');
        if (ogDescription)
            ogDescription.content = this.t('og_description');
        // Update Twitter tags
        const twitterTitle = document.querySelector('meta[name="twitter:title"]');
        if (twitterTitle)
            twitterTitle.content = this.t('og_title');
        const twitterDescription = document.querySelector('meta[name="twitter:description"]');
        if (twitterDescription)
            twitterDescription.content = this.t('twitter_description');
        // Update app title
        const appTitle = document.querySelector('meta[name="apple-mobile-web-app-title"]');
        if (appTitle)
            appTitle.content = this.t('app_title');
    }
    updateStaticContent() {
        // Header
        const headerTitle = document.getElementById('header-title');
        if (headerTitle)
            headerTitle.textContent = this.t('header_title');
        const headerTagline = document.getElementById('header-tagline');
        if (headerTagline)
            headerTagline.textContent = this.t('header_tagline');
        // Landing page
        const landingTitle = document.getElementById('landing-title');
        if (landingTitle)
            landingTitle.textContent = this.t('landing_title');
        const landingDescription = document.getElementById('landing-description');
        if (landingDescription)
            landingDescription.textContent = this.t('landing_description');
        const landingSubtitle = document.getElementById('landing-subtitle');
        if (landingSubtitle)
            landingSubtitle.textContent = this.t('landing_subtitle');
        // Features
        const featureMobile = document.getElementById('feature-mobile');
        if (featureMobile)
            featureMobile.innerHTML = this.t('feature_mobile');
        const featureCalculator = document.getElementById('feature-calculator');
        if (featureCalculator)
            featureCalculator.innerHTML = this.t('feature_calculator');
        const featureCommentary = document.getElementById('feature-commentary');
        if (featureCommentary)
            featureCommentary.innerHTML = this.t('feature_commentary');
        const featureAudio = document.getElementById('feature-audio');
        if (featureAudio)
            featureAudio.innerHTML = this.t('feature_audio');
        const featureSaving = document.getElementById('feature-saving');
        if (featureSaving)
            featureSaving.innerHTML = this.t('feature_saving');
        const whyChooseTitle = document.getElementById('why-choose-title');
        if (whyChooseTitle)
            whyChooseTitle.textContent = this.t('why_choose_title');
        const whyChooseDescription = document.getElementById('why-choose-description');
        if (whyChooseDescription)
            whyChooseDescription.textContent = this.t('why_choose_description');
        // Buttons
        const newGameBtn = document.getElementById('new-game-btn');
        if (newGameBtn)
            newGameBtn.textContent = this.t('start_button');
        const nameCrewTitle = document.getElementById('name-crew-title');
        if (nameCrewTitle)
            nameCrewTitle.textContent = this.t('name_crew_title');
        const addPlayerBtn = document.getElementById('add-player-btn');
        if (addPlayerBtn)
            addPlayerBtn.textContent = this.t('add_pirate_button');
        const startGameBtn = document.getElementById('start-game-btn');
        if (startGameBtn)
            startGameBtn.textContent = this.t('set_sail_button');
        const cancelSetupBtn = document.getElementById('cancel-setup-btn');
        if (cancelSetupBtn)
            cancelSetupBtn.textContent = this.t('back_to_port_button');
        const newGameIngameBtn = document.getElementById('new-game-ingame-btn');
        if (newGameIngameBtn)
            newGameIngameBtn.textContent = this.t('new_game_button');
        // Game section
        const currentBountyTitle = document.getElementById('current-bounty-title');
        if (currentBountyTitle)
            currentBountyTitle.textContent = this.t('current_bounty_title');
        const readScoresBtn = document.getElementById('read-scores-btn');
        if (readScoresBtn)
            readScoresBtn.innerHTML = `üîä ${this.t('read_scores_button').replace('üîä ', '')}`;
        const gameCompleteTitle = document.getElementById('game-complete-title');
        if (gameCompleteTitle)
            gameCompleteTitle.textContent = this.t('game_complete_title');
        const roundLabel = document.getElementById('round-label');
        if (roundLabel)
            roundLabel.textContent = this.t('round_label');
        const addRoundBtn = document.getElementById('add-round-btn');
        if (addRoundBtn)
            addRoundBtn.textContent = this.t('record_round_button');
        // Modal
        const modalTitle = document.getElementById('modal-title');
        if (modalTitle)
            modalTitle.textContent = this.t('confirm_action_title');
        const keepNamesLabel = document.getElementById('keep-names-label');
        if (keepNamesLabel)
            keepNamesLabel.textContent = this.t('keep_names_label');
        const newPlayersBtn = document.getElementById('new-players-btn');
        if (newPlayersBtn)
            newPlayersBtn.textContent = this.t('new_players_button');
        const cancelNewGameBtn = document.getElementById('cancel-new-game-btn');
        if (cancelNewGameBtn)
            cancelNewGameBtn.textContent = this.t('cancel_button');
        const modalConfirm = document.getElementById('modal-confirm');
        if (modalConfirm)
            modalConfirm.textContent = this.t('aye_button');
        const modalCancel = document.getElementById('modal-cancel');
        if (modalCancel)
            modalCancel.textContent = this.t('nay_button');
        // Footer
        const disclaimerTitle = document.getElementById('disclaimer-title');
        if (disclaimerTitle)
            disclaimerTitle.textContent = this.t('disclaimer_title');
        const disclaimerText1 = document.getElementById('disclaimer-text-1');
        if (disclaimerText1)
            disclaimerText1.textContent = this.t('disclaimer_text_1');
        const disclaimerText2 = document.getElementById('disclaimer-text-2');
        if (disclaimerText2)
            disclaimerText2.textContent = this.t('disclaimer_text_2');
        const feedbackText = document.getElementById('feedback-text');
        if (feedbackText)
            feedbackText.textContent = this.t('feedback_text');
    }
    // PWA Install Functionality
    initializePWA() {
        // Guard for test environment
        if (typeof document === 'undefined')
            return;
        // Don't show install buttons if already in standalone mode (installed)
        if ((window.matchMedia && window.matchMedia('(display-mode: standalone)').matches) ||
            window.navigator.standalone) {
            this.hideInstallButtons();
            return;
        }
        // Add event listeners to existing install buttons
        this.setupInstallButtons();
    }
    setupInstallButtons() {
        // Add event listener to the header install button
        const installBtnHeader = document.getElementById('install-app-btn-header');
        if (installBtnHeader) {
            installBtnHeader.addEventListener('click', () => this.showInstallInstructions());
        }
    }
    hideInstallButtons() {
        const installBtnHeader = document.getElementById('install-app-btn-header');
        if (installBtnHeader) {
            installBtnHeader.style.display = 'none';
        }
    }
    showInstallInstructions() {
        // Show instructions for manual installation
        let modal = document.getElementById('install-instructions-modal');
        if (!modal) {
            modal = document.createElement('div');
            modal.id = 'install-instructions-modal';
            modal.className = 'install-modal';
            modal.innerHTML = `
                <div class="install-modal-content">
                    <h3>${this.t('add_to_home_title')}</h3>
                    <div class="install-instructions">
                        <p><strong>${this.t('android_chrome_title')}</strong></p>
                        <ol>
                            <li>${this.t('android_step_1')}</li>
                            <li>${this.t('android_step_2')}</li>
                            <li>${this.t('android_step_3')}</li>
                        </ol>
                        <p><strong>${this.t('ios_safari_title')}</strong></p>
                        <ol>
                            <li>${this.t('ios_step_1')}</li>
                            <li>${this.t('ios_step_2')}</li>
                            <li>${this.t('ios_step_3')}</li>
                        </ol>
                    </div>
                    <button class="install-modal-close" onclick="this.parentElement.parentElement.style.display='none'">${this.t('close_button')}</button>
                </div>
            `;
            document.body.appendChild(modal);
        }
        modal.style.display = 'flex';
    }
    // Public method for testing the scoring logic
    testCalculateRoundScore(bid, actual, bonus, roundNumber) {
        return this.viewModel.testCalculateRoundScore(bid, actual, bonus, roundNumber);
    }
    // Public method for validation testing
    testValidateSinglePlayerInput(bid, actual, bonus, playerName, roundNumber) {
        return this.viewModel.validateSinglePlayerInput(bid, actual, bonus, playerName, roundNumber);
    }
}
// Initialize game
const game = new SkullKingGame();
// Expose class for testing
window.SkullKingGame = SkullKingGame;
